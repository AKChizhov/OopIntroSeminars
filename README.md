# ДЗ к семинарам по ООП

# К семинару №1 Урок 1. Принципы ООП: Инкапсуляция, наследование, полиморфизм
* Создать класс Player с полями id (long), name (String), damage (double) healthPoint (hp) (double).
 У класса должен быть конструктор, который принимает только name. Идентификатор присваивается автоматически 
 из последовательности (1, 2, ...) Каждый класс должен уметь "бить" другого Player'а void attack
 (Player player) -> player1.attack(player2) Внутри метода игрок, на котором вызван метод уменьшает здоровье игрока,
  который передан в метод Придумать несколько классов с разными параметрами жизней и атаки по-умолчанию 
  Player player = new Tank("name");
* * Придумать, все, что захочется и обогатить проект
* Понасоздавать объектов и стравить их друг с другом

# Урок 2. Принципы ООП Абстракция и интерфейсы. Пример проектирования
Представьте, что вы пишете класс Reder, который отвечает за вывод на экран текущего уровня жизней и усталости какого-то объекта.
(Подразумеваем, что вывод на экран - это просто печать в консоль)
У класса есть 1 метод, который принимает тип Object и делает следующее:
* 1. Если object типа HasHealthPoint, то выводим его уровень жизни
* 2. Если object типа Tiredness, то выводим его уровень усталости
При этом текст значения должен иметь цвет в соответствии с правилом:
BLACK(0, 24), RED(25, 50), GREEN(51-100)
* 3. Создать несколько классов:
* 3. 1 Здание. Имеет только жизни.
* 3. 2 Персонаж . Имеет и жизни, и усталость.
* 3. 3 Мост.
Подробности на семинаре и в приложенном архиве

# Урок 3. Некоторые стандартные интерфейсы Java и примеры их использования
Создать класс Notebook с полями:
1. Стоимость (int)
2. Оперативная память (int)
Нагенерить объектов этого класса, создать список и отсортировать его в трех вариантах:
1. По возрастанию цены
2. По убыванию цены
3. По оперативке по убыванию. Если оперативки равны - по убыванию цены.
4. (+) придумать свои параметры и отсортировать по ним

## Дополнения и изменения, сделанные при выполнении ДЗ к Уроку 3.
1. Оперативная память (double);
2. В классе Notebook реализованы поля: Торговая марка, Объем памяти, Тактовая частота, Стоимость;
3. Сортировка по цене, размеру оперативной пямяти, тактовой частоте с помощью интерфейса Comparator;
4. Сортировка длине (кол-ву букв) торговой марки с помощью интерфейса Comparable
  * по уменьшению;
  * по увеличению;
5. Реализовано сложное сравнение:
  * при равном объеме памяти сравнение по убыванию тактовой частоты;
  * при одинаковых объемах памяти и тактовой частоты сравнение по убыванию стоимости;